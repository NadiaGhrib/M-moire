# -*- coding: utf-8 -*-
"""Test stat.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bnhz5o1kKM2JD0DSPmt--CVzsGSobQrn
"""

pip install quandl

import quandl
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.arima_model import ARIMA
from pandas.plotting import register_matplotlib_converters
register_matplotlib_converters()
import warnings
import itertools
import statsmodels.api as sm

df= quandl.get("BITSTAMP/USD", authtoken="Sf9Hs9BMkLK6QLEewDU9")

df.head()

df[['Last']].plot(figsize=(20,10), linewidth=5, fontsize=20)
plt.xlabel('time', fontsize=20);

price = df[['Last']]
price.rolling(12).mean().plot(figsize=(20,10), linewidth=5, fontsize=20)
plt.xlabel('time', fontsize=20);

#On peut utiliser des pandas et les méthodes diff () et plot () pour calculer et tracer la différence de premier ordre

price.diff().plot(figsize=(20,10), linewidth=5, fontsize=20)
plt.xlabel('time', fontsize=20);

pd.plotting.autocorrelation_plot(price);

#Statistiques roulantes : Tracer la moyenne mobile et l’écart-type mobile. 
#La série temporelle est stationnaire si elle reste constante dans le temps (à l’œil nu, regardez si les lignes sont droites et parallèles à l’axe des x)

price.rolling(12).mean().plot(figsize=(20,10), linewidth=5, fontsize=20)
plt.xlabel('time', fontsize=20);

rolling_mean = price.rolling(window = 12).mean()
rolling_std = price.rolling(window = 12).std()

plt.plot(price, color = 'blue', label = 'Origine')
plt.plot(rolling_mean, color = 'red', label = 'Moyenne mobile')
plt.plot(rolling_std, color = 'black', label = 'Ecart-type mobile')
plt.legend(loc = 'best')
plt.title('Moyenne et Ecart-type mobiles')
plt.show()

#Test de Dickey-Fuller augmenté (ADF) : La série temporelle est considérée comme stationnaire si la valeur p est faible (selon l’hypothèse nulle) 
#et si les valeurs critiques à des intervalles de confiance de 1%, 5%, 10% sont aussi proches que possible des statistiques 
#de l’ADF (Augmented Dickey-Fuller)
#(Une moyenne mobile sur 10 jours calcule la moyenne des prix de clôture des 10 premiers jours comme premier point de données. 
#Et ainsi de suite pour chaque point de donnée suivante)

result = adfuller(price['Last'])

print('Statistiques ADF : {}'.format(result[0]))
print('p-value : {}'.format(result[1]))
print('Valeurs Critiques :')
for key, value in result[4].items():
    print('\t{}: {}'.format(key, value))


#Problème : p valeur n'est pas faible 
#La statistique ADF est loin des valeurs critiques et la p-value est supérieure au seuil (0,05). 
#Donc la série temporelle n’est pas stationnaire.

#On regarde la tendance : 

from statsmodels.tsa.tsatools import detrend
notrend = detrend(df.Last)
df["notrend"] = notrend
df.plot( y=["Last", "notrend"], figsize=(14,4))

#Prendre le logarithme de la variable dépendante est un moyen simple de réduire le taux d’augmentation de la moyenne mobile :
df_log = np.log(price)
plt.plot(df_log)

#On refait les test : 

df_log.rolling(12).mean().plot(figsize=(20,10), linewidth=5, fontsize=20)
plt.xlabel('time', fontsize=20);

rolling_mean = df_log.rolling(window = 12).mean()
rolling_std = df_log.rolling(window = 12).std()

plt.plot(df_log, color = 'blue', label = 'Origine')
plt.plot(rolling_mean, color = 'red', label = 'Moyenne mobile')
plt.plot(rolling_std, color = 'black', label = 'Ecart-type mobile')
plt.legend(loc = 'best')
plt.title('Moyenne et Ecart-type mobiles')
plt.show()

result = adfuller(df_log['Last'])

print('Statistiques ADF : {}'.format(result[0]))
print('p-value : {}'.format(result[1]))
print('Valeurs Critiques :')
for key, value in result[4].items():
    print('\t{}: {}'.format(key, value))


#La serie n'est pas stationnaire 
#Cependant, Le modèle ARIMA suppose ou exigent que la série temporelle soit stationnaire.